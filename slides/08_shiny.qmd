---
title: "8 Shiny Development"
author: "Daniel"
description: "Best Practices for Shiny App Development<br/>[Photo by Pixabay on pexels.com]{.copyright}"
image: thumbnails/shiny.jpg
editor_options: 
  chunk_output_type: console
---

## Why are best practices important for Shiny?

- Shiny is in itself more complex than usual R code
- Small apps can quickly evolve into giant apps
- It seems first possible to test everything by hand, clicking around
- For one-off, throw-away, one-screen Shiny apps that is ok.
- Here we talk about best practices for more-than-once used Shiny apps

# Design

## Design: Collaborate with your customer

- Involve your customer from the first ideation
- Identify the roles and responsibilities
- Make reasonable assumptions about user skills and knowledge
- Show early wireframes, prototypes, beta versions and get feedback

## UI Design: Wireframing

- Wireframing is powerful for aligning in customer discussions
- Focus on the vision and functionality
- Keep the UI as simple as possible
- Know your target as developer during coding and review process
- Wireframing software:
  - [draw.io](https://draw.io)
  - [Balsamiq](https://balsamiq.com/)
  
## UI Design: Example wireframe

![](resources/wireframe.png){fig-align="center"}

# Architecture

## Architecture: Minimize code in Shiny

- Minimize the code inside the Shiny UI/server
- Because it will always be easier to test things that live outside of Shiny
- Let's look at an example from the [Mastering Shiny](https://mastering-shiny.org/scaling-functions.html#function-upload) book

## Minimize Shiny Example: Before

::: columns
::: {.column width="50%"}
```{r, echo = TRUE}
#| code-line-numbers: "6-11"
#| style: font-size:0.7em!important;
server <- function(input, output, session) {
  data <- reactive({
    req(input$file)
    name <- input$file$name
    path <- input$file$datapath
    ext <- tools::file_ext(name)
    switch(ext,
      csv = vroom::vroom(path, ","),
      tsv = vroom::vroom(path, "\t"),
      validate("Invalid file")
    )
  })
  
  output$head <- renderTable({
    head(data(), input$n)
  })
}
```
:::

::: {.column width="50%"}
The `ext` and `switch()` part validates the file extension and then loads the 
file.

Independent of Shiny reactive!
:::
:::

## Minimize Shiny Example: After

::: columns
::: {.column width="50%"}
```{r, echo = TRUE}
#| code-line-numbers: "1-8,13-16"
#| style: font-size:0.7em!important;
load_file <- function(name, path) {
  ext <- tools::file_ext(name)
  switch(ext,
    csv = vroom::vroom(path, ","),
    tsv = vroom::vroom(path, "\t"),
    validate("Invalid file")
  )
}

server <- function(input, output, session) {
  data <- reactive({
    req(input$file)
    load_file(
      input$file$name, 
      input$file$datapath
    )
  })
  
  output$head <- renderTable({
    head(data(), input$n)
  })
}
```
:::

::: {.column width="50%"}
1) normal function, `validate()` will give a simple error outside of Shiny

2) server is much easier to read now and only half the size

3) can test `load_file()` interactively in console

4) can unit tests `load_file()` separately (business as usual)
:::
:::

## Minimize Shiny: Separate packages

- On the macro level, this also applies to packages
- Larger Shiny apps will need to live as an R package
- The business logic best lives in another R package
- That package can then also be used without the Shiny interface
- You can use `staged.dependencies` to allow "joint" pull requests
- Example: `teal.modules.clinical` as the Shiny package, `tern` as a business logic package

# Modules

## Modules: Building blocks of the Shiny app

- Shiny modules generalize functions 
- Allows to coordinate UI and server code
- Breaks the app code into reusable and testable units
- Let's look at an example from the [Mastering Shiny](https://mastering-shiny.org/scaling-modules.html#module-motivation) book

## Modules Example: Before

::: columns
::: {.column width="60%"}
![](resources/without-modules.png){fig-align="center"}
:::

::: {.column width="40%"}
- Difficult to understand what is going on
- Need longer names / parentheses to differentiate tables / plots / variables
in different places
- Hard to test
:::
:::

## Modules Example: After

::: columns
::: {.column width="60%"}
![](resources/with-modules.png){fig-align="center"}
:::

::: {.column width="40%"}
- Can easily see the 4 different parts of the app
- Naming becomes simpler for vars / tables / plots
- Can reuse the modules separately in other apps
- Can test the modules separately
:::
:::

## Modules: Considerations similar to Functions

- What should be configurable? 
  - Think about reuse needs for module
- How to organize arguments?
    - Use consistent naming conventions
    - Keep the right order of the arguments
- Avoid dependencies between arguments
  - Use instead parameter object pattern
- How to write good and maintainable code?
  - Follow all the clean code rules from the previous chapter!
  
# Reactivity

## Reactivity

When building production shiny apps you won't get around learning reactivity.

Some guidance:

- Keep user interface simple → often keeps reactivity simple → often less confusing to user
- Resolve reactive inputs early on & validate generously
- Design towards "stringy" reactivity graphs
- Don't interrupt reactivity
- Preferably use
  - `reactive` over `reactiveValues` 
  - `observeEvent` over `observe`

## Reactivity: Resolve early & validate generously

```{r, echo = TRUE}
#| code-line-numbers: "3-6,8-13"
server <- function(input, output, session) {
  output$plot <- renderPlot({
    # resolve reactive values
    xvar <- input$xvar
    yvar <- input$yvar
    req(xvar, yvar)
    
    # validate – is it likely that the plot will be meaningful?
    validate(
      need(xvar %in% names(df), glue("xvar \"{xvar}\" does not exist in data")),
      need(yvar %in% names(df), glue("yvar \"{yvar}\" does not exist in data")),
      need(nrow(df) > 3, "too few data points for meaningful plot")
    )
    
    # write "business logic" in a unit testable function
    my_special_plot(df[[xvar]], df[[yvar]])
  })
}
```

## Reactivity: Debugging with global variables

```{r, echo = TRUE}
#| code-line-numbers: "16"
server <- function(input, output, session) {
  output$plot <- renderPlot({
    # resolve reactive values
    xvar <- input$xvar
    yvar <- input$yvar
    req(xvar, yvar)
    
    # validate – is it likely that the plot will be meaningful?
    validate(
      need(xvar %in% names(df), glue("xvar \"{xvar}\" does not exist in data")),
      need(yvar %in% names(df), glue("yvar \"{yvar}\" does not exist in data")),
      need(nrow(df) > 3, "too few data points for meaningful plot")
    )
    
    # write "business logic" in a unit testable function
    .GlobalEnv$xvar <- xvar; .GlobalEnv$yvar <- yvar;  stop()
    my_special_plot(df[[xvar]], df[[yvar]])
  })
}
```

## Reactivity: "Stringy" reactivity graph

::: columns
::: {.column width="50%"}
Bad
![](resources/connected.png){fig-align="center"}
Many edges, difficult to anticipate reactivity behaviour
:::
 
::: {.column width="50%"}
Good
![](resources/stringy.png){fig-align="center"}
This "stringy" reactivity graph is easier to understand and debug
:::
:::

# Testing

## Testing: From Icecream to Pyramid

::: columns
::: {.column width="50%"}
Bad

![](resources/icecream.png){height=400}

- cannot always test manually
- can easily introduce bugs
:::
 
::: {.column width="50%"}
Good

![](resources/pyramid.png){height=400}

- manual testing is reduced
- only for "playing around"
:::
:::

## Testing: Snapshot tests for UI

::: columns
::: {.column width="50%"}
```{r, echo = TRUE, eval = FALSE}
#| code-line-numbers: "5-9"
test_that("myInput UI works", {
  input <- "foo"
  set.seed(123)
  datasets <- mock_datasets()
  expect_snapshot(myInput(
    "my_test",
    datasets = datasets,
    input = input
  ))
})
```
:::

::: {.column width="50%"}
- Shiny UI functions return shiny tag objects, i.e. HTML code
- Can use snapshot tests to avoid accidental changes
- Value is limited
- Can create issues sometimes (non-reproducible hashes)
:::
:::

## Testing: Shiny server tests

::: columns
::: {.column width="50%"}
```{r, echo = TRUE, eval = FALSE}
test_that("server works", {
  testServer(server, {
    session$setInputs(...)

    print(reactive1())
    print(output$output1)
    # etc

    # To interactively play:
    # browser()
  
    expect_equal(...)
    # etc.
  })
})

```
:::

::: {.column width="50%"}
- Code is run inside the server function
- Can access reactives, outputs, etc.
- Session object simulates user actions and time
- Note: need to insert `browser()`
- Also works for module server functions
- Limitation: No UI, no JavaScript
:::
:::

## Testing: Shiny app tests

::: columns
::: {.column width="50%"}
```{r, echo = TRUE, eval = FALSE}
test_that("my app works", {
  library(shinytest)
  app <- ShinyDriver$new(
    "myAppDir/",
    loadTimeout = 1e5, 
    phantomTimeout = 1e5,
    debug = "all"
  ) # app$getDebugLog()
  app$takeScreenshot()
  app$setInputs(name = "Hadley")
  app$getValue("greeting")
  app$click("reset")
  app$getValue("greeting")
})
```
:::

::: {.column width="50%"}
- `{shinytest2}` is recent alternative
- Usually the app is defined in `myAppDir/app.R`
- New app instance from `ShinyDriver$new()`
- Full Shiny app in a headless browser
- Can look into it via `takeScreenshot()`
- We can set inputs, get values of inputs/outputs, click buttons etc.
:::
:::

# References

-   Adrian Waddell, Pawel Rucki, Daniel Sabanes Bove (2022).
    Lessons for designing scalable and maintainable Shiny apps Tutorial at useR 2022.
    \[[Youtube recording](https://www.youtube.com/watch?v=7o9qjsw4aDU)\]
